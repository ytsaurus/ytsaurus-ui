import {mergeStateOnClusterChange} from '../../../store/reducers/utils';
import {Action} from 'redux';
import {
    TABLETS_BUNDLES_ACTIVE_ACCOUNT,
    TABLETS_BUNDLES_LOAD_FAILURE,
    TABLETS_BUNDLES_LOAD_REQUEST,
    TABLETS_BUNDLES_LOAD_SUCCESS,
    TABLETS_BUNDLES_PARTIAL,
} from '../../../constants/tablets';
import {ActionD, SortState, YTError} from '../../../types';

export interface TabletsBundlesState {
    loaded: boolean;
    loading: boolean;
    error: YTError | undefined;

    cells: Array<TabletCell>;
    bundles: Array<TabletBundle>;

    writableByName: Map<string, boolean>;

    bundlesNameFilter: string;
    bundlesAccountFilter: string;
    bundlesTagNodeFilter: string;

    cellsIdFilter: string;
    cellsBundleFilter: string;
    cellsHostFilter: string;

    bundlesSort: SortState<keyof TabletBundle>;
    cellsSort: SortState<keyof TabletCell>;

    activeBundle: string;

    bundlesTableMode: BundlesTableMode;
    bundleDefaultConfig?: BundleDefaultConfig;
}

export type BundlesTableMode = 'default' | 'tablets' | 'tablets_memory';

export interface TabletCell {
    id: string;
    bundle: string;
    health: TabletBundle['health'];
    memory: number;
    compressed: number;
    tablets: number;
    uncompressed: number;
    peerAddress: string;
    state: string;

    peer: TabletCellPeer;
    peers: Array<TabletCellPeer>;
}

export interface TabletCellPeer {
    address: string;
    last_seen: string;
    state: string;
}

export interface BundleControllerConfig {
    cpu_limits: CPULimits;
    memory_limits: MemoryLimits;
    tablet_node_count: number;
    tablet_node_resource_guarantee: BundleResourceGuarantee;
    rpc_proxy_count: number;
    rpc_proxy_resource_guarantee: BundleResourceGuarantee;
}

export interface BundleResourceGuarantee {
    memory: number;
    vcpu: number;
    net: number;
    // The type field, generated by us when saving the config for the first time. Those this field is not from DTO
    type?: string;
}

export interface MemoryLimits {
    reserved?: number;
    tablet_static?: number;
    tablet_dynamic?: number;
    compressed_block_cache?: number;
    uncompressed_block_cache?: number;
    versioned_chunk_meta?: number;
    lookup_row_cache?: number;
    key_filter_block_cache?: number;
}

export interface CPULimits {
    write_thread_pool_size: number;
    lookup_thread_pool_size?: number;
    query_thread_pool_size?: number;
}

export interface BundleDataCenter {
    rpc_proxy_nanny_service: string;
    tablet_node_nanny_service: string;
    yp_cluster: string;
}

export interface BundleDefaultConfigData {
    tablet_node_sizes: {
        [size: string]: {
            resource_guarantee: BundleResourceGuarantee;
            default_config: {
                cpu_limits: {
                    write_thread_pool_size: number;
                };
                memory_limits: Record<string, number>;
            };
        };
    };
    rpc_proxy_sizes: {
        [size: string]: {
            resource_guarantee: BundleResourceGuarantee;
        };
    };
    data_centers?: {
        [name: string]: BundleDataCenter;
    };
}

export interface BundleDefaultConfig {
    [zoneName: string]: BundleDefaultConfigData;
}

export interface OrchidBundleResource {
    vcpu: number;
    memory: number;
    net?: number;
}

type Alert = {
    id: string;
    description: string;
};

export interface OrchidBundlesData {
    alerts: Alert[];

    assigned_spare_tablet_nodes: {};
    allocated_tablet_nodes: AllocatedInstancesMap;
    allocating_tablet_nodes: InProgressInstancesMap;
    allocating_tablet_node_count: number;
    deallocating_tablet_node_count: number;

    assigned_spare_rpc_proxies: {};
    allocated_rpc_proxies: AllocatedInstancesMap;
    allocating_rpc_proxies: InProgressInstancesMap;
    allocating_rpc_proxy_count: number;
    deallocating_rpc_proxy_count: number;

    removing_cell_count: number;
    resource_quota: OrchidBundleResource;
    resource_allocated: OrchidBundleResource;
}

export type AllocatedInstancesMap = Record<string, AllocatedInstance>;
export interface AllocatedInstance {
    resource: OrchidBundleResource;
    pod_id: string;
    yp_cluster: string;
    removing?: boolean;
}

export type InProgressInstancesMap = Record<string, InProgressInstance>;
export interface InProgressInstance {
    hulk_request_link: string;
    hulk_request_state: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED';
    instance_info: AllocatedInstance;
}

export interface OrchidBundles {
    [bundleName: string]: OrchidBundlesData;
}

export interface TabletBundle {
    $attributes: unknown;

    alerts: number;
    banned: number;
    decommissioned: number;
    health: 'good' | 'failed' | 'initializing';
    full: number;
    online: number;
    offline: number;
    bundle: string;
    compressed: number;
    memory: number;
    nodes?: Array<string>;
    tabletCells: number;
    tablets: number;
    uncompressed: number;

    bundle_controller_target_config?: BundleControllerConfig;
    enable_bundle_balancer: boolean;
    enable_bundle_controller: boolean;
    changelog_account: string;
    snapshot_account: string;
    node_tag_filter: string;
    unique_node_tag: boolean;
    zone?: string;

    tablet_count: number;
    tablet_count_limit: number;
    tablet_count_free: number;
    tablet_count_percentage: number;

    tablet_static_memory: number;
    tablet_static_memory_limit: number;
    tablet_static_memory_free: number;
    tablet_static_memory_percentage: number;
}

const persistedState: Pick<
    TabletsBundlesState,
    | 'bundlesSort'
    | 'cellsSort'
    | 'bundlesNameFilter'
    | 'bundlesAccountFilter'
    | 'bundlesTagNodeFilter'
    | 'cellsHostFilter'
    | 'cellsBundleFilter'
    | 'activeBundle'
    | 'bundlesTableMode'
> = {
    bundlesSort: {column: 'bundle', order: 'asc'},
    cellsSort: {},

    bundlesNameFilter: '',
    bundlesAccountFilter: '',
    bundlesTagNodeFilter: '',

    cellsBundleFilter: '',
    cellsHostFilter: '',

    activeBundle: '',
    bundlesTableMode: 'default',
};

const ephemeralState: Pick<
    TabletsBundlesState,
    Exclude<keyof TabletsBundlesState, keyof typeof persistedState>
> = {
    loading: false,
    loaded: false,
    error: undefined,

    cells: [],
    bundles: [],

    writableByName: new Map<string, boolean>(),

    cellsIdFilter: '',

    bundleDefaultConfig: undefined,
};

export const initialState: TabletsBundlesState = {
    ...ephemeralState,
    ...persistedState,
};

function reducer(state = initialState, action: TabletsBundlesAction): TabletsBundlesState {
    switch (action.type) {
        case TABLETS_BUNDLES_LOAD_REQUEST:
            return {...state, loading: true};
        case TABLETS_BUNDLES_LOAD_FAILURE:
            return {...state, loading: false, error: action.data};
        case TABLETS_BUNDLES_LOAD_SUCCESS:
            return {...state, ...action.data, loaded: true, loading: false};
        case TABLETS_BUNDLES_PARTIAL:
            return {...state, ...action.data};
        case TABLETS_BUNDLES_ACTIVE_ACCOUNT:
            return {...state, ...action.data};
    }
    return state;
}

export type TabletsPartialAction = ActionD<
    typeof TABLETS_BUNDLES_PARTIAL,
    Partial<
        Pick<
            TabletsBundlesState,
            | 'bundlesSort'
            | 'bundlesNameFilter'
            | 'bundlesAccountFilter'
            | 'bundlesTagNodeFilter'
            | 'cellsSort'
            | 'cellsIdFilter'
            | 'cellsBundleFilter'
            | 'cellsHostFilter'
            | 'bundlesTableMode'
            | 'writableByName'
        >
    >
>;

export type TabletsBundlesAction =
    | Action<typeof TABLETS_BUNDLES_LOAD_REQUEST>
    | ActionD<typeof TABLETS_BUNDLES_LOAD_FAILURE, YTError>
    | ActionD<
          typeof TABLETS_BUNDLES_LOAD_SUCCESS,
          Pick<TabletsBundlesState, 'cells' | 'bundles' | 'bundleDefaultConfig'>
      >
    | TabletsPartialAction
    | ActionD<typeof TABLETS_BUNDLES_ACTIVE_ACCOUNT, Pick<TabletsBundlesState, 'activeBundle'>>;

const tablet_cell_bundles = mergeStateOnClusterChange(ephemeralState, persistedState, reducer);

export default tablet_cell_bundles;
